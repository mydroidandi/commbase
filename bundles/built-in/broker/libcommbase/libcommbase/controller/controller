################################################################################
#                                  libcommbase                                 #
#                                                                              #
# A collection of libraries to centralize common functions that can be shared  #
# across multiple conversational AI assistant projects                         #
#                                                                              #
# Change History                                                               #
# 05/02/2023  Esteban Herrera Original code.                                   #
#                           Add new history entries as needed.                 #
#                                                                              #
#                                                                              #
################################################################################
################################################################################
################################################################################
#                                                                              #
#  Copyright (c) 2023-present Esteban Herrera C.                               #
#  stv.herrera@gmail.com                                                       #
#                                                                              #
#  This program is free software; you can redistribute it and/or modify        #
#  it under the terms of the GNU General Public License as published by        #
#  the Free Software Foundation; either version 3 of the License, or           #
#  (at your option) any later version.                                         #
#                                                                              #
#  This program is distributed in the hope that it will be useful,             #
#  but WITHOUT ANY WARRANTY; without even the implied warranty of              #
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               #
#  GNU General Public License for more details.                                #
#                                                                              #
#  You should have received a copy of the GNU General Public License           #
#  along with this program; if not, write to the Free Software                 #
#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA   #

# controller
# Parses messages saved in JSON object format files by the STT engine, searching
# for the messages that match control patterns. The recognized text is then
# saved in JSON files.
# In case the STT engine is commbase-stt-vosk-p, it requires the configuration
# variable COMMBASE_STT_VOSK_P_PARSE_CONTROL_MESSAGES_ON set to "False".
controller() {
	# The app configuration file
	source $COMMBASE_APP_DIR/config/app.conf

	# The function that reads the lines from the control message pattern files
	source $COMMBASE_APP_DIR/bundles/built-in/broker/libcommbase/libcommbase/routines/read_lines_from_file
	source $COMMBASE_APP_DIR/bundles/built-in/broker/libcommbase/libcommbase/controller/echo_lines_from_file_variable

	# Read a whole file into a variable
	json_object=$(<$COMMBASE_APP_DIR$RESULT_MESSAGE_RECORDING_FILE);

	# Extract message from the JSON object
	new_message=$(echo $json_object | jq --raw-output '."message"');

	# Set the control message pattern file paths from the environment config file
	control_stop_previous_command_patterns_file=$COMMBASE_APP_DIR$CONTROL_STOP_PREVIOUS_COMMAND_PATTERNS_FILE;
	control_accept_changes_patterns_file=$COMMBASE_APP_DIR$CONTROL_ACCEPT_CHANGES_PATTERNS_FILE;
	control_deny_changes_patterns_file=$COMMBASE_APP_DIR$CONTROL_DENY_CHANGES_PATTERNS_FILE;
	control_select_option_number_one_patterns_file=$COMMBASE_APP_DIR$CONTROL_SELECT_OPTION_NUMBER_ONE_PATTERNS_FILE;
	control_select_option_number_two_patterns_file=$COMMBASE_APP_DIR$CONTROL_SELECT_OPTION_NUMBER_TWO_PATTERNS_FILE;
	control_select_option_number_three_patterns_file=$COMMBASE_APP_DIR$CONTROL_SELECT_OPTION_NUMBER_THREE_PATTERNS_FILE;
	control_select_option_number_four_patterns_file=$COMMBASE_APP_DIR$CONTROL_SELECT_OPTION_NUMBER_FOUR_PATTERNS_FILE;
	control_skip_question_patterns_file=$COMMBASE_APP_DIR$CONTROL_SKIP_QUESTION_PATTERNS_FILE;
	control_request_the_current_mode_patterns_file=$COMMBASE_APP_DIR$CONTROL_REQUEST_THE_CURRENT_MODE_PATTERNS_FILE;
	control_enter_the_normal_mode_patterns_file=$COMMBASE_APP_DIR$CONTROL_ENTER_THE_NORMAL_MODE_PATTERNS_FILE;
	control_enter_the_conversational_mode_patterns_file=$COMMBASE_APP_DIR$CONTROL_ENTER_THE_CONVERSATIONAL_MODE_PATTERNS_FILE;
	control_enter_the_expert_mode_patterns_file=$COMMBASE_APP_DIR$CONTROL_ENTER_THE_EXPERT_MODE_PATTERNS_FILE;
	control_enter_the_follow_up_mode_patterns_file=$COMMBASE_APP_DIR$CONTROL_ENTER_THE_FOLLOW_UP_MODE_PATTERNS_FILE;

	# Load all the control pattern files in variables

	# CONTROL_STOP_PREVIOUS_COMMAND
	control_stop_previous_command_patterns=$(read_lines_from_file $control_stop_previous_command_patterns_file);
	echo_lines_from_file_variable;

	# CONTROL_ACCEPT_CHANGES
	control_accept_changes_patterns=$(read_lines_from_file $control_accept_changes_patterns_file);

	#	CONTROL_DENY_CHANGES
	control_deny_changes_patterns=$(read_lines_from_file $control_deny_changes_patterns_file);

	#	CONTROL_SELECT_OPTION_NUMBER_ONE
	control_select_option_number_one_patterns=$(read_lines_from_file $control_select_option_number_one_patterns_file);

	#	CONTROL_SELECT_OPTION_NUMBER_TWO
	control_select_option_number_two_patterns=$(read_lines_from_file $control_select_option_number_two_patterns_file);

	#	CONTROL_SELECT_OPTION_NUMBER_THREE
	control_select_option_number_three_patterns=$(read_lines_from_file $control_select_option_number_three_patterns_file);

	#	CONTROL_SELECT_OPTION_NUMBER_FOUR
	control_select_option_number_four_patterns=$(read_lines_from_file $control_select_option_number_four_patterns_file);

	#	CONTROL_SKIP_QUESTION
	control_skip_question_patterns=$(read_lines_from_file $control_skip_question_patterns_file);

	#	CONTROL_REQUEST_THE_CURRENT_MODE
	control_request_the_current_mode_patterns=r$(read_lines_from_file $control_request_the_current_mode_patterns_file);

	#	CONTROL_ENTER_THE_NORMAL_MODE
	control_enter_the_normal_mode_patterns=$(read_lines_from_file $control_enter_the_normal_mode_patterns_file);

	#	CONTROL_ENTER_THE_CONVERSATIONAL_MODE
	control_enter_the_conversational_mode_patterns=r$(read_lines_from_file $control_enter_the_conversational_mode_patterns_file);

	#	CONTROL_ENTER_THE_EXPERT_MODE
	control_enter_the_expert_mode_patterns=$(read_lines_from_file $control_enter_the_expert_mode_patterns_file);

	#	CONTROL_ENTER_THE_FOLLOW_UP_MODE
	control_enter_the_follow_up_mode_patterns=$(read_lines_from_file $control_enter_the_follow_up_mode_patterns_file);

	# Define control messages
	# To change a control command do not do that here; use its patterns file
	# instead
	CONTROL_STOP_PREVIOUS_COMMAND="okay stop"
	CONTROL_ACCEPT_CHANGES="okay accept"
	CONTROL_DENY_CHANGES="okay deny"
	CONTROL_SELECT_OPTION_NUMBER_ONE="okay select the option number one"
	CONTROL_SELECT_OPTION_NUMBER_TWO="okay select the option number two"
	CONTROL_SELECT_OPTION_NUMBER_THREE="okay select the option number three"
	CONTROL_SELECT_OPTION_NUMBER_FOUR="okay select the option number four"
	CONTROL_SKIP_QUESTION="okay skip that question"
	CONTROL_REQUEST_THE_CURRENT_MODE="okay which mode are you in"
	CONTROL_ENTER_THE_NORMAL_MODE="okay enter the normal mode"
	CONTROL_ENTER_THE_CONVERSATIONAL_MODE="okay enter the conversational mode"
	CONTROL_ENTER_THE_EXPERT_MODE="okay enter the expert mode"
	CONTROL_ENTER_THE_FOLLOW_UP_MODE="okay enter the follow up mode"

	# If new_message is not empty
	if [[ -n $new_message ]]; then
	

	echo $new_message
	
	fi

	
	
	
		#TODO: Parse the patterns files and look for matches with $new_message
	
		for 
		
		
		
					# Create the JSON object
					json_data="{\"control\":\"$control\"}"
					# Record the control message string to result_message_recording_file as a JSON object
					#echo "$json_data" > "$result_message_recording_file"
					echo "$json_data" > "./TMP.txt"						
					found_match=true
					# Manage the result message
					bash "$COMMBASE_APP_DIR/src/skill"
					break  # Exit the inner loop if a match is found
				fi
			done <<< "$patterns"

			if $found_match; then
					break  # Exit the outer loop if a match is found
			fi
			
			
		done


				#echo $patterns
				#echo $message
				##echo $message | jq '."message"'





	tmux select-window -t 1 && tmux select-pane -t 1 && printf "\e[1;41mCOMMBASE:\e[1;m I don't understand: %s" "$trim_str"
	tmux select-window -t 1 && tmux select-pane -t 4
	exit 99
}

# Call the parse_skill_ if the script is run directly (not sourced)
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
	(controller)
fi

exit 99

